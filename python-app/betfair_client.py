"""
Betfair API client using betfairlightweight library.
Handles SSL certificate authentication for Betfair Italy.
Includes Streaming API for real-time price updates.
"""

import os
import tempfile
import threading
import queue
import betfairlightweight
from betfairlightweight import filters
from betfairlightweight.streaming import StreamListener
from datetime import datetime, timedelta

FOOTBALL_ID = "1"

MARKET_TYPES = {
    'MATCH_ODDS': 'Esito Finale (1X2)',
    'CORRECT_SCORE': 'Risultato Esatto',
    'OVER_UNDER_05': 'Over/Under 0.5 Goal',
    'OVER_UNDER_15': 'Over/Under 1.5 Goal',
    'OVER_UNDER_25': 'Over/Under 2.5 Goal',
    'OVER_UNDER_35': 'Over/Under 3.5 Goal',
    'OVER_UNDER_45': 'Over/Under 4.5 Goal',
    'OVER_UNDER_55': 'Over/Under 5.5 Goal',
    'OVER_UNDER_65': 'Over/Under 6.5 Goal',
    'OVER_UNDER_75': 'Over/Under 7.5 Goal',
    'BOTH_TEAMS_TO_SCORE': 'Goal/No Goal',
    'DOUBLE_CHANCE': 'Doppia Chance',
    'DRAW_NO_BET': 'Draw No Bet',
    'HALF_TIME': 'Primo Tempo',
    'HALF_TIME_SCORE': 'Risultato Primo Tempo',
    'HALF_TIME_FULL_TIME': 'Primo Tempo/Finale',
    'SECOND_HALF_CORRECT_SCORE': 'Risultato Secondo Tempo',
    'ASIAN_HANDICAP': 'Handicap Asiatico',
    'HANDICAP': 'Handicap Europeo',
    'FIRST_GOAL_SCORER': 'Primo Marcatore',
    'LAST_GOAL_SCORER': 'Ultimo Marcatore',
    'ANYTIME_SCORER': 'Marcatore',
    'TOTAL_GOALS': 'Totale Goal',
    'TEAM_A_TOTAL_GOALS': 'Goal Casa',
    'TEAM_B_TOTAL_GOALS': 'Goal Trasferta',
    'TEAM_TOTAL_GOALS': 'Goal Squadra',
    'ODD_OR_EVEN': 'Pari/Dispari Goal',
    'WINNING_MARGIN': 'Margine Vittoria',
    'NEXT_GOAL': 'Prossimo Goal',
    'CLEAN_SHEET': 'Clean Sheet',
    'WIN_TO_NIL': 'Vince a Zero',
    'CORNER_ODDS': 'Corner',
    'CORNER_MATCH_BET': 'Corner Vincente',
    'TOTAL_CORNERS': 'Totale Corner',
    'BOOKING_ODDS': 'Cartellini',
    'TOTAL_BOOKINGS': 'Totale Cartellini',
    'FIRST_HALF_GOALS_05': 'Goal 1T O/U 0.5',
    'FIRST_HALF_GOALS_15': 'Goal 1T O/U 1.5',
    'FIRST_HALF_GOALS_25': 'Goal 1T O/U 2.5',
    'PENALTY_TAKEN': 'Rigore',
    'TO_SCORE_BOTH_HALVES': 'Segna in Entrambi i Tempi',
    'WIN_BOTH_HALVES': 'Vince Entrambi i Tempi',
    'HIGHEST_SCORING_HALF': 'Tempo con Piu Goal',
    'METHOD_OF_VICTORY': 'Tipo di Vittoria',
    'SENDING_OFF': 'Espulsione',
}


class PriceStreamListener(StreamListener):
    """Custom listener for processing streaming price updates."""
    
    def __init__(self, price_callback):
        super().__init__()
        self.price_callback = price_callback
        self.market_cache = {}
    
    def on_data(self, raw_data):
        """Called when new data arrives from stream."""
        try:
            if hasattr(raw_data, 'data'):
                data = raw_data.data
            else:
                data = raw_data
                
            if isinstance(data, dict) and 'mc' in data:
                for market_change in data['mc']:
                    market_id = market_change.get('id')
                    if market_id and 'rc' in market_change:
                        runners_data = []
                        for rc in market_change['rc']:
                            runner_info = {
                                'selectionId': rc.get('id'),
                                'backPrices': rc.get('atb', []),
                                'layPrices': rc.get('atl', [])
                            }
                            runners_data.append(runner_info)
                        
                        if self.price_callback:
                            self.price_callback(market_id, runners_data)
        except Exception as e:
            print(f"Stream data error: {e}")


class BetfairClient:
    def __init__(self, username, app_key, cert_pem, key_pem):
        # Aggressive cleaning of all string values to remove newlines/whitespace
        self.username = self._clean_string(username)
        self.app_key = self._clean_string(app_key)
        self.cert_pem = cert_pem.strip() if cert_pem else cert_pem
        self.key_pem = key_pem.strip() if key_pem else key_pem
        self.client = None
        self.temp_certs_dir = None
        self.stream = None
        self.stream_thread = None
        self.streaming_active = False
        self.price_callbacks = {}
    
    @staticmethod
    def _clean_string(value):
        """Remove all whitespace, newlines, and control characters from a string."""
        if value is None:
            return None
        if isinstance(value, bytes):
            value = value.decode('utf-8', errors='ignore')
        # Remove all whitespace and newlines
        return ''.join(value.split())
    
    def _create_temp_cert_files(self):
        """Create temporary certificate directory for betfairlightweight.
        
        betfairlightweight expects a directory containing:
        - client-2048.crt (or .pem)
        - client-2048.key (or .pem)
        """
        import shutil
        
        self.temp_certs_dir = tempfile.mkdtemp(prefix='betfair_certs_')
        
        cert_file_path = os.path.join(self.temp_certs_dir, 'client-2048.crt')
        with open(cert_file_path, 'w') as f:
            f.write(self.cert_pem)
        
        key_file_path = os.path.join(self.temp_certs_dir, 'client-2048.key')
        with open(key_file_path, 'w') as f:
            f.write(self.key_pem)
        
        return self.temp_certs_dir
    
    def _cleanup_temp_files(self):
        """Clean up temporary certificate directory."""
        import shutil
        try:
            if self.temp_certs_dir and os.path.exists(self.temp_certs_dir):
                shutil.rmtree(self.temp_certs_dir)
        except:
            pass
    
    def login(self, password):
        """
        Login to Betfair Italy using SSL certificate authentication.
        Uses locale="italy" for Italian Exchange endpoints.
        """
        certs_dir = self._create_temp_cert_files()
        
        try:
            self.client = betfairlightweight.APIClient(
                username=self.username,
                password=password,
                app_key=self.app_key,
                certs=certs_dir,
                locale="italy"
            )
            
            self.client.login()
            
            if not self.client.session_token:
                raise Exception("Nessun token ricevuto - verifica credenziali")
            
            return {
                'session_token': self.client.session_token,
                'expiry': (datetime.now() + timedelta(hours=8)).isoformat()
            }
        except betfairlightweight.exceptions.LoginError as e:
            self._cleanup_temp_files()
            raise Exception(f"Credenziali errate o account bloccato: {str(e)}")
        except betfairlightweight.exceptions.CertsError as e:
            self._cleanup_temp_files()
            raise Exception(f"Errore certificato SSL - verifica che .crt e .key siano corretti: {str(e)}")
        except betfairlightweight.exceptions.APIError as e:
            self._cleanup_temp_files()
            raise Exception(f"Errore API Betfair: {str(e)}")
        except Exception as e:
            self._cleanup_temp_files()
            error_msg = str(e)
            if "SSL" in error_msg.upper() or "CERTIFICATE" in error_msg.upper():
                raise Exception(f"Errore SSL - il certificato potrebbe non essere valido: {error_msg}")
            elif "timeout" in error_msg.lower():
                raise Exception("Timeout connessione - riprova")
            else:
                raise Exception(f"Login fallito: {error_msg}")
    
    def logout(self):
        """Logout from Betfair and stop streaming."""
        self.stop_streaming()
        if self.client:
            try:
                self.client.logout()
            except:
                pass
        self._cleanup_temp_files()
        self.client = None
    
    def get_account_funds(self):
        """Get account balance."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        account = self.client.account.get_account_funds()
        return {
            'available': account.available_to_bet_balance,
            'exposure': account.exposure,
            'total': account.available_to_bet_balance + abs(account.exposure)
        }
    
    def get_football_events(self, include_inplay=True):
        """Get upcoming and in-play football events."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        time_filter = filters.time_range(
            from_=datetime.now(),
            to=datetime.now() + timedelta(days=2)
        )
        
        # Get upcoming events
        events = self.client.betting.list_events(
            filter=filters.market_filter(
                event_type_ids=[FOOTBALL_ID],
                market_start_time=time_filter
            )
        )
        
        # Also get in-play events
        inplay_events = []
        if include_inplay:
            try:
                inplay_events = self.client.betting.list_events(
                    filter=filters.market_filter(
                        event_type_ids=[FOOTBALL_ID],
                        in_play_only=True
                    )
                )
            except:
                pass
        
        # Combine events (avoid duplicates)
        event_ids = set()
        result = []
        
        # Add in-play events first (marked as LIVE)
        for event in inplay_events:
            event_ids.add(event.event.id)
            result.append({
                'id': event.event.id,
                'name': event.event.name,
                'countryCode': event.event.country_code,
                'openDate': event.event.open_date.isoformat() if event.event.open_date else None,
                'marketCount': event.market_count,
                'inPlay': True
            })
        
        # Add upcoming events
        for event in events:
            if event.event.id not in event_ids:
                result.append({
                    'id': event.event.id,
                    'name': event.event.name,
                    'countryCode': event.event.country_code,
                    'openDate': event.event.open_date.isoformat() if event.event.open_date else None,
                    'marketCount': event.market_count,
                    'inPlay': False
                })
        
        # Sort: in-play first, then by date
        result.sort(key=lambda x: (not x.get('inPlay', False), x['openDate'] or ''))
        return result
    
    def get_available_markets(self, event_id):
        """Get all available markets for an event (no type restriction)."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        # Fetch ALL markets without type restriction
        markets = self.client.betting.list_market_catalogue(
            filter=filters.market_filter(
                event_ids=[event_id]
            ),
            market_projection=['MARKET_START_TIME', 'MARKET_DESCRIPTION'],
            max_results=100
        )
        
        # Get in-play status for these markets
        market_ids = [m.market_id for m in markets]
        in_play_status = {}
        
        if market_ids:
            try:
                market_books = self.client.betting.list_market_book(
                    market_ids=market_ids[:50]  # API limit
                )
                for book in market_books:
                    in_play_status[book.market_id] = book.inplay if hasattr(book, 'inplay') else False
            except:
                pass
        
        result = []
        for market in markets:
            market_type = market.market_type if hasattr(market, 'market_type') else None
            display_name = MARKET_TYPES.get(market_type, market.market_name)
            is_inplay = in_play_status.get(market.market_id, False)
            
            result.append({
                'marketId': market.market_id,
                'marketName': market.market_name,
                'marketType': market_type,
                'displayName': display_name,
                'startTime': market.market_start_time.isoformat() if market.market_start_time else None,
                'inPlay': is_inplay
            })
        
        return result
    
    def get_market_with_prices(self, market_id):
        """Get a specific market with runner details and prices."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        markets = self.client.betting.list_market_catalogue(
            filter=filters.market_filter(
                market_ids=[market_id]
            ),
            market_projection=['RUNNER_DESCRIPTION', 'MARKET_START_TIME'],
            max_results=1
        )
        
        if not markets:
            raise Exception("Mercato non trovato")
        
        market = markets[0]
        
        price_data = self.client.betting.list_market_book(
            market_ids=[market_id],
            price_projection=filters.price_projection(
                price_data=['EX_BEST_OFFERS']
            )
        )
        
        if not price_data:
            raise Exception("Quote non disponibili")
        
        runners = []
        price_book = price_data[0]
        
        for runner in market.runners:
            runner_prices = None
            for pb_runner in price_book.runners:
                if pb_runner.selection_id == runner.selection_id:
                    runner_prices = pb_runner
                    break
            
            back_price = None
            lay_price = None
            back_size = None
            lay_size = None
            
            if runner_prices and runner_prices.ex:
                if runner_prices.ex.available_to_back:
                    back_price = runner_prices.ex.available_to_back[0].price
                    back_size = runner_prices.ex.available_to_back[0].size
                if runner_prices.ex.available_to_lay:
                    lay_price = runner_prices.ex.available_to_lay[0].price
                    lay_size = runner_prices.ex.available_to_lay[0].size
            
            runners.append({
                'selectionId': runner.selection_id,
                'runnerName': runner.runner_name,
                'sortPriority': runner.sort_priority,
                'backPrice': back_price,
                'layPrice': lay_price,
                'backSize': back_size,
                'laySize': lay_size,
                'status': runner_prices.status if runner_prices else 'ACTIVE'
            })
        
        market_status = 'OPEN'
        if hasattr(price_book, 'status'):
            market_status = price_book.status
        
        is_inplay = False
        if hasattr(price_book, 'inplay'):
            is_inplay = price_book.inplay
        
        return {
            'marketId': market_id,
            'marketName': market.market_name,
            'startTime': market.market_start_time.isoformat() if market.market_start_time else None,
            'runners': runners,
            'status': market_status,
            'inPlay': is_inplay
        }
    
    def get_correct_score_market(self, event_id):
        """Get correct score market for an event (legacy method)."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        markets = self.client.betting.list_market_catalogue(
            filter=filters.market_filter(
                event_ids=[event_id],
                market_type_codes=['CORRECT_SCORE']
            ),
            market_projection=['RUNNER_DESCRIPTION', 'MARKET_START_TIME'],
            max_results=1
        )
        
        if not markets:
            raise Exception("Mercato Risultato Esatto non trovato")
        
        return self.get_market_with_prices(markets[0].market_id)
    
    def start_streaming(self, market_ids, price_callback):
        """
        Start streaming price updates for specified markets.
        
        Args:
            market_ids: List of market IDs to stream
            price_callback: Function(market_id, runners_data) called on price updates
        """
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        self.stop_streaming()
        
        try:
            self.stream = self.client.streaming.create_stream(
                listener=PriceStreamListener(price_callback)
            )
            
            market_filter = filters.streaming_market_filter(
                market_ids=market_ids
            )
            
            market_data_filter = filters.streaming_market_data_filter(
                fields=['EX_BEST_OFFERS', 'EX_TRADED']
            )
            
            self.stream.subscribe_to_markets(
                market_filter=market_filter,
                market_data_filter=market_data_filter
            )
            
            self.streaming_active = True
            self.stream_thread = threading.Thread(
                target=self._run_stream,
                daemon=True
            )
            self.stream_thread.start()
            
            return True
            
        except Exception as e:
            self.streaming_active = False
            raise Exception(f"Errore avvio streaming: {str(e)}")
    
    def _run_stream(self):
        """Run the stream in a background thread."""
        try:
            if self.stream:
                self.stream.start()
        except Exception as e:
            print(f"Stream error: {e}")
        finally:
            self.streaming_active = False
    
    def stop_streaming(self):
        """Stop the active stream."""
        self.streaming_active = False
        if self.stream:
            try:
                self.stream.stop()
            except:
                pass
            self.stream = None
        self.stream_thread = None
    
    def is_streaming(self):
        """Check if streaming is active."""
        return self.streaming_active and self.stream is not None
    
    def place_bets(self, market_id, instructions):
        """
        Place bets on Betfair.
        
        instructions: list of {
            'selectionId': int,
            'side': 'BACK' or 'LAY',
            'price': float,
            'size': float
        }
        """
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        for inst in instructions:
            if inst['side'] == 'BACK' and inst['size'] < 2.0:
                raise Exception(f"Puntata minima BACK: 2.00 EUR (richiesto: {inst['size']:.2f})")
        
        limit_orders = []
        for inst in instructions:
            limit_orders.append(
                betfairlightweight.filters.limit_order(
                    size=inst['size'],
                    price=inst['price'],
                    persistence_type='LAPSE'
                )
            )
        
        place_instructions = []
        for i, inst in enumerate(instructions):
            place_instructions.append(
                betfairlightweight.filters.place_instruction(
                    selection_id=inst['selectionId'],
                    side=inst['side'],
                    order_type='LIMIT',
                    limit_order=limit_orders[i]
                )
            )
        
        result = self.client.betting.place_orders(
            market_id=market_id,
            instructions=place_instructions
        )
        
        return {
            'status': result.status,
            'marketId': result.market_id,
            'instructionReports': [
                {
                    'status': ir.status,
                    'betId': ir.bet_id,
                    'placedDate': ir.placed_date.isoformat() if ir.placed_date else None,
                    'averagePriceMatched': ir.average_price_matched,
                    'sizeMatched': ir.size_matched
                }
                for ir in result.instruction_reports
            ] if result.instruction_reports else []
        }
    
    def get_current_orders(self, market_ids=None):
        """Get current unmatched and partially matched orders."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        order_filter = {}
        if market_ids:
            order_filter['market_ids'] = market_ids
        
        orders = self.client.betting.list_current_orders(**order_filter)
        
        result = {
            'matched': [],
            'unmatched': [],
            'partiallyMatched': []
        }
        
        for order in orders.orders if orders.orders else []:
            order_data = {
                'betId': order.bet_id,
                'marketId': order.market_id,
                'selectionId': order.selection_id,
                'side': order.side,
                'price': order.price_size.price if order.price_size else None,
                'size': order.price_size.size if order.price_size else None,
                'sizeMatched': order.size_matched,
                'sizeRemaining': order.size_remaining,
                'averagePriceMatched': order.average_price_matched,
                'status': order.status,
                'placedDate': order.placed_date.isoformat() if order.placed_date else None
            }
            
            if order.size_remaining == 0 and order.size_matched > 0:
                result['matched'].append(order_data)
            elif order.size_remaining > 0 and order.size_matched > 0:
                result['partiallyMatched'].append(order_data)
            elif order.size_remaining > 0:
                result['unmatched'].append(order_data)
        
        return result
    
    def cancel_orders(self, market_id, bet_ids=None):
        """Cancel unmatched orders."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        instructions = []
        if bet_ids:
            for bet_id in bet_ids:
                instructions.append(
                    betfairlightweight.filters.cancel_instruction(bet_id=bet_id)
                )
        
        result = self.client.betting.cancel_orders(
            market_id=market_id,
            instructions=instructions if instructions else None
        )
        
        return {
            'status': result.status,
            'instructionReports': [
                {
                    'status': ir.status,
                    'sizeCancelled': ir.size_cancelled if hasattr(ir, 'size_cancelled') else 0
                }
                for ir in result.instruction_reports
            ] if result.instruction_reports else []
        }
    
    def get_market_profit_and_loss(self, market_ids):
        """Get profit/loss for markets (for cashout calculation)."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        result = self.client.betting.list_market_profit_and_loss(
            market_ids=market_ids,
            include_settled_bets=False,
            include_bsp_bets=False
        )
        
        market_pnl = {}
        for market in result:
            runners_pnl = []
            for runner in market.profit_and_losses if market.profit_and_losses else []:
                runners_pnl.append({
                    'selectionId': runner.selection_id,
                    'ifWin': runner.if_win,
                    'ifLose': runner.if_lose if hasattr(runner, 'if_lose') else None
                })
            market_pnl[market.market_id] = runners_pnl
        
        return market_pnl
    
    def calculate_cashout(self, market_id, selection_id, side, matched_stake, matched_price):
        """
        Calculate cashout stake and potential P/L.
        
        Cashout works by placing an opposite bet to lock in profit/loss.
        - If original bet was BACK, cashout is LAY
        - If original bet was LAY, cashout is BACK
        
        For green-up (equal profit all outcomes):
        - BACK position: LAY stake = (back_stake * back_price) / lay_price
        - LAY position: BACK stake = (lay_stake * lay_price) / back_price
        
        Returns dict with cashout_stake, green_up, profit_if_win, profit_if_lose
        """
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        # Get current prices
        price_data = self.client.betting.list_market_book(
            market_ids=[market_id],
            price_projection=filters.price_projection(
                price_data=['EX_BEST_OFFERS']
            )
        )
        
        if not price_data:
            raise Exception("Quote non disponibili")
        
        current_price = None
        for runner in price_data[0].runners:
            if runner.selection_id == selection_id:
                if side == 'BACK':
                    # For BACK cashout, we need LAY price
                    if runner.ex and runner.ex.available_to_lay:
                        current_price = runner.ex.available_to_lay[0].price
                else:
                    # For LAY cashout, we need BACK price
                    if runner.ex and runner.ex.available_to_back:
                        current_price = runner.ex.available_to_back[0].price
                break
        
        if not current_price:
            raise Exception("Prezzo corrente non disponibile")
        
        # Calculate cashout stake using correct hedge formulas
        if side == 'BACK':
            # Original BACK bet: hedge by LAYing
            # LAY stake = (back_stake * back_price) / lay_price
            # This ensures equal profit on all outcomes
            cashout_stake = (matched_stake * matched_price) / current_price
            
            # Green-up profit calculation:
            # If wins: back_profit - lay_liability = stake*(back_price-1) - cashout_stake*(lay_price-1)
            # If loses: -back_stake + lay_stake = -stake + cashout_stake
            profit_if_win = matched_stake * (matched_price - 1) - cashout_stake * (current_price - 1)
            profit_if_lose = -matched_stake + cashout_stake
            
        else:
            # Original LAY bet: hedge by BACKing
            # BACK stake = (lay_stake * lay_price) / back_price
            cashout_stake = (matched_stake * matched_price) / current_price
            
            # Original LAY liability
            original_liability = matched_stake * (matched_price - 1)
            
            # If wins: -lay_liability + back_profit = -liability + cashout_stake*(back_price-1)
            # If loses: +lay_stake - back_stake = matched_stake - cashout_stake
            profit_if_win = -original_liability + cashout_stake * (current_price - 1)
            profit_if_lose = matched_stake - cashout_stake
        
        # Round stake to 2 decimal places, enforce €2 minimum for Italy
        cashout_stake = round(cashout_stake, 2)
        cashout_stake = max(2.0, cashout_stake)
        
        # Recalculate P/L with adjusted stake
        if side == 'BACK':
            profit_if_win = matched_stake * (matched_price - 1) - cashout_stake * (current_price - 1)
            profit_if_lose = -matched_stake + cashout_stake
        else:
            original_liability = matched_stake * (matched_price - 1)
            profit_if_win = -original_liability + cashout_stake * (current_price - 1)
            profit_if_lose = matched_stake - cashout_stake
        
        # Green-up is the guaranteed profit (average of both outcomes with proper hedge)
        # With perfect hedge, profit_if_win should equal profit_if_lose
        green_up = (profit_if_win + profit_if_lose) / 2
        
        return {
            'cashout_stake': cashout_stake,
            'current_price': current_price,
            'profit_if_win': round(profit_if_win, 2),
            'profit_if_lose': round(profit_if_lose, 2),
            'green_up': round(green_up, 2),
            'cashout_side': 'LAY' if side == 'BACK' else 'BACK'
        }
    
    def execute_cashout(self, market_id, selection_id, cashout_side, cashout_stake, cashout_price):
        """
        Execute cashout by placing opposite bet.
        
        Returns placement result.
        """
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        # Round stake to 2 decimal places, minimum €2 for Italy
        stake = max(2.0, round(cashout_stake, 2))
        
        instructions = [
            betfairlightweight.filters.place_instruction(
                order_type='LIMIT',
                selection_id=selection_id,
                side=cashout_side,
                limit_order=betfairlightweight.filters.limit_order(
                    size=stake,
                    price=cashout_price,
                    persistence_type='LAPSE'
                )
            )
        ]
        
        result = self.client.betting.place_orders(
            market_id=market_id,
            instructions=instructions
        )
        
        return {
            'status': result.status,
            'betId': result.instruction_reports[0].bet_id if result.instruction_reports else None,
            'sizeMatched': result.instruction_reports[0].size_matched if result.instruction_reports else 0,
            'averagePriceMatched': result.instruction_reports[0].average_price_matched if result.instruction_reports else None
        }
    
    def get_live_events_only(self):
        """Get only in-play football events."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        inplay_events = self.client.betting.list_events(
            filter=filters.market_filter(
                event_type_ids=[FOOTBALL_ID],
                in_play_only=True
            )
        )
        
        result = []
        for event in inplay_events:
            result.append({
                'id': event.event.id,
                'name': event.event.name,
                'countryCode': event.event.country_code,
                'openDate': event.event.open_date.isoformat() if event.event.open_date else None,
                'marketCount': event.market_count,
                'inPlay': True
            })
        
        return result
    
    def get_live_markets(self, event_id=None):
        """Get all in-play markets, optionally filtered by event."""
        if not self.client:
            raise Exception("Non connesso a Betfair")
        
        market_filter_params = {
            'event_type_ids': [FOOTBALL_ID],
            'in_play_only': True
        }
        if event_id:
            market_filter_params['event_ids'] = [event_id]
        
        markets = self.client.betting.list_market_catalogue(
            filter=filters.market_filter(**market_filter_params),
            market_projection=['RUNNER_DESCRIPTION', 'MARKET_START_TIME', 'EVENT'],
            max_results=100
        )
        
        result = []
        for market in markets:
            market_type = market.market_type if hasattr(market, 'market_type') else None
            display_name = MARKET_TYPES.get(market_type, market.market_name)
            event_name = market.event.name if hasattr(market, 'event') and market.event else ''
            
            result.append({
                'marketId': market.market_id,
                'marketName': market.market_name,
                'marketType': market_type,
                'displayName': display_name,
                'eventId': market.event.id if hasattr(market, 'event') and market.event else None,
                'eventName': event_name,
                'startTime': market.market_start_time.isoformat() if market.market_start_time else None,
                'inPlay': True
            })
        
        return result
